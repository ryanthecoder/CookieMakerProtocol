# Happy Holidays! This is the Opentrons Tough Cookie Maker Protocol
# This protocol is meant to be paired with the Opentrons Tough Cookie labware definition
from opentrons import protocol_api
from opentrons.protocol_api import Labware
from opentrons.types import Point, Location
from typing import List
from pydantic import BaseModel
import math

metadata = {
    "protocolName": "Opentrons Tough Cookie Protocol",
    "author": "Casey Batten",
}

requirements = {
    "apiLevel": "2.27",
    "robotType": "Flex",

}

# Amount of uL of frosting to dispense per mm
# This totals out to 1000~ uL of frosting for a single left-to-right line across the cookie
# So at a 1 tip for a full line, you could do 85 straight lines top to bottom with a single tiprack
FROSTING_PER_MM = 7.8

class CookiePoint(BaseModel):
    line_id: int
    color: str
    x: float
    y: float

def add_parameters(parameters: protocol_api.ParameterContext):
    parameters.add_csv_file(
        variable_name="cookie_pattern",
        display_name="Cookie Pattern",
        description=(
            "Uses a set of waypoints and lines generated by a drawing app"
        )
    )

def order_cookie_pattern(csv_data: List[List[str]]) -> List[CookiePoint]:
    """Return a dictionary of cookie points by unique line ID"""
    # csv objects go by row
    # row 1 would be: csv_data[0]
    # row 1 contains unique ID, color, x, y
    cookie_pattern: List[CookiePoint] = []
    for row in csv_data:
        point = CookiePoint(
            line_id=row[0],
            color=row[1],
            x=row[2],
            y=row[3]
        )
        cookie_pattern.append(point)

    return cookie_pattern


def run(protocol: protocol_api.ProtocolContext):
    # Retrieve Run Time Parameters
    csv_data = protocol.params.cookie_pattern.parse_as_csv()
    cookie_pattern = order_cookie_pattern(csv_data)

    # Load frosting tips and pipette
    tips = protocol.load_labware("opentrons_flex_96_tiprack_1000ul", "A2")
    pipette = protocol.load_instrument("flex_1channel_1000", "left", tip_racks=[tips])

    # Load cookie
    # TODO: make the cookie definition
    cookie = protocol.load_labware("opentrons_tough_cookie", "C2")

    # Load cookie dispenser and tip trash
    cookie_chute = protocol.load_waste_chute()
    tip_trash = protocol.load_trash_bin("A3")

    frosting_lw = protocol.load_labware(f"opentrons_6_tuberack_nest_50ml_conical", "B2")

    # Frosting declarations
    # Red
    red_frosting = protocol.define_liquid("red_frosting", "Red Frosting", "#FF0000")
    red_frosting_container = frosting_lw.well("A1")
    frosting_lw.load_liquid(["A1"], 45000, red_frosting)
    red_tip = tips["A1"]
    pipette.pick_up_tip(red_tip)
    pipette.require_liquid_presence(red_frosting_container)
    pipette.return_tip()
    # White
    white_frosting = protocol.define_liquid("white_frosting", "White Frosting", "#FFFFFF")
    white_frosting_container = frosting_lw.well("A2")
    frosting_lw.load_liquid(["A2"], 45000, white_frosting)
    white_tip = tips["B1"]
    pipette.pick_up_tip(white_tip)
    pipette.require_liquid_presence(white_frosting_container)
    pipette.return_tip()
    # Blue
    blue_frosting = protocol.define_liquid("blue_frosting", "Blue Frosting", "#0000FF")
    blue_frosting_container = frosting_lw.well("B1")
    frosting_lw.load_liquid(["B1"], 45000, blue_frosting)
    blue_tip = tips["C1"]
    pipette.pick_up_tip(blue_tip)
    pipette.require_liquid_presence(blue_frosting_container)
    pipette.return_tip()
    # Green
    green_frosting = protocol.define_liquid("green_frosting", "Green Frosting", "#00FF00")
    green_frosting_container = frosting_lw.well("B2")
    frosting_lw.load_liquid(["B2"], 45000, green_frosting_container)
    green_tip = tips["D1"]
    pipette.pick_up_tip(green_tip)
    pipette.require_liquid_presence(green_frosting_container)
    pipette.return_tip()
    # Yellow
    yellow_frosting = protocol.define_liquid("yellow_frosting", "Yellow Frosting", "#FFFF00")
    yellow_frosting_container = frosting_lw.well("C1")
    frosting_lw.load_liquid(["C1"], 45000, yellow_frosting)
    yellow_tip = tips["E1"]
    pipette.pick_up_tip(yellow_tip)
    pipette.require_liquid_presence(yellow_frosting_container)
    pipette.return_tip()

    #Get cookie Height

    pipette.pick_up_tip(ips["F1"])
    well_z = pipette.measure_liquid_height(cookie)
    pipette.return_tip()


    def _color_to_tip(color: str) -> Well:
        match color:
            case "Red":
                return red_tip
            case "White":
                return white_tip
            case "Blue":
                return blue_tip
            case "Green":
                return green_tip
            case "Yellow":
                return yellow_tip
            case _:
                # Use white frosting if the color was unidentified
                return white_tip

    def _color_to_well(color: str) -> Well:
        match color:
            case "Red":
                return red_frosting_container
            case "White":
                return white_frosting_container
            case "Blue":
                return blue_frosting_container
            case "Green":
                return green_frosting_container
            case "Yellow":
                return yellow_frosting_container
            case _:
                # Use white frosting if the color was unidentified
                return white_frosting_container


    # Handle cookie decoration!
    previous_color = "none"
    for i in range(len(cookie_pattern)):
        if i !=0 and cookie_pattern[i-1].line_id == cookie_pattern[i].line_id:
            if previous_color != cookie_pattern[i].color:
                if pipette.has_tip:
                    pipette.drop_tip(tip_trash)
                pipette.pick_up_tip(_color_to_tip(cookie_pattern[i].color))
            # These are part of the same line, start pipetting!
            dist = math.sqrt(((cookie_pattern[i].x - cookie_pattern[i-1].x) ** 2) + ((cookie_pattern[i].y - cookie_pattern[i-1].y) ** 2))
            frosting_volume = FROSTING_PER_MM * dist if (FROSTING_PER_MM * dist) <= 1000 else 1000
            # Casey NOTE: Try to prevent lines longer than the max length (127MM) from generating in the image app?
            # Probably not possible anyways unless the app got a larger canvas?
            protocol.comment(f"First point- x:{cookie_pattern[i-1].x} y:{cookie_pattern[i-1].y}  Second point- x:{cookie_pattern[i].x} y:{cookie_pattern[i].y}")


            start_loc = cookie["A1"].bottom(z=well_z).move(
                Point(
                    x = cookie_pattern[i-1].x,
                    y = cookie_pattern[i-1].y,
                    z=0
                )
            )
            end_loc = cookie["A1"].bottom(z=well_z).move(
                Point(
                    x = cookie_pattern[i].x,
                    y = cookie_pattern[i].y,
                    z=0
                )
            )

            # Casey NOTE: Currently this results in us moving a few mm at a time, dispensing, and homing, over and over
            # it works but it would take forever and not look smooth. We need some kind of line smoothing formula, maybe from the painting app?
            try:
                pipette.dispense(
                    frosting_volume,
                    location=start_loc,
                    end_location=end_loc
                )
            except:
                pipette.blow_out(tip_trash)
                pipette.aspirate(
                    volume=1000,
                    location=_color_to_well(cookie_pattern[i].color).meniscus(z=-1, target="start"),
                    end_location=_color_to_well(cookie_pattern[i].color).meniscus(z=-1, target="end")
                )
                pipette.dispense(
                    frosting_volume,
                    location=start_loc,
                    end_location=end_loc
                )
    pipette.drop_tip(tip_trash)

    # Dispense the cookie!
    protocol.capture_image(home_before=True, filename="Cookie_pic", zoom=2.0)
    protocol.pause(msg="GET READY TO CATCH THE DISPENSED COOKIE! HAPPY HOLIDAYS!")
    #protocol.move_labware(cookie, cookie_chute, use_gripper=True)
