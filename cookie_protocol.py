# Happy Holidays! This is the Opentrons Tough Cookie Maker Protocol
# This protocol is meant to be paired with the Opentrons Tough Cookie labware definition
from opentrons import protocol_api
from opentrons.protocol_api import Labware, LiquidClass
from opentrons.types import Point, Location
from opentrons_shared_data.liquid_classes.types import (
    TransferPropertiesDict,
    AspiratePropertiesDict,
    SingleDispensePropertiesDict,
    MultiDispensePropertiesDict,
    SubmergeDict,
    RetractAspirateDict,
    RetractDispenseDict,
    MixPropertiesDict,
    BlowoutPropertiesDict,
    TouchTipPropertiesDict,
    TipPositionDict,
    DelayPropertiesDict,
)
from opentrons_shared_data.liquid_classes.liquid_class_definition import (
    PositionReference,
    BlowoutLocation,
    Coordinate
)
from opentrons.protocol_api._liquid_properties import(
    TipPosition
)
from opentrons.protocol_api.core.engine import transfer_components_executor as tx_comps_executor
from typing import List
from pydantic import BaseModel
import math

metadata = {
    "protocolName": "Opentrons Tough Cookie Protocol",
    "author": "Casey Batten",
}

requirements = {
    "apiLevel": "2.27",
    "robotType": "Flex",

}

# Global frosting values
FROSTING_PER_MM = 23.4

FROSTING_FLOW_RATE=400

FROSTING_MAX_VOLUME=500

DISPENSE_HEIGHT_ABOVE_COOKIE = 2.0
WAYPOINT_Z_HEIGHT = 10.0

# Known frosting colors
FROSTING_COLORS = ['Red', 'Blue', 'Green', 'Yellow', 'White']

class CookiePoint(BaseModel):
    line_id: int
    color: str
    x: float
    y: float

def add_parameters(parameters: protocol_api.ParameterContext):
    parameters.add_csv_file(
        variable_name="cookie_pattern",
        display_name="Cookie Pattern",
        description=(
            "Uses a set of waypoints and lines generated by a drawing app"
        )
    )
    parameters.add_bool(
        variable_name="use_lld",
        display_name="Use LLD",
        description=(
            "Use LLD or just assume load liquid amounts."
        ),
        default=True,
    )
    parameters.add_bool(
        variable_name="use_gripper",
        display_name="Use Gripper",
        description=(
            "Use Gripper to drop the cookie out of the Waste Chute at the end."
        ),
        default=False,
    )
    parameters.add_float(
        variable_name="frosting_flow_rate",
        display_name="Frosting Flow Rate",
        default=FROSTING_FLOW_RATE,
        minimum=200.0,
        maximum=500.0,
    )
    parameters.add_float(
        variable_name="frosting_per_mm",
        display_name="Frosting Per mm",
        default=FROSTING_PER_MM,
        minimum=FROSTING_PER_MM/2,
        maximum=FROSTING_PER_MM*5,
    )

def order_cookie_pattern(csv_data: List[List[str]]) -> List[CookiePoint]:
    """Return a dictionary of cookie points by unique line ID"""
    # csv objects go by row
    # row 1 would be: csv_data[0]
    # row 1 contains unique ID, color, x, y
    unsorted_cookie_pattern: List[CookiePoint] = []
    for row in csv_data:
        point = CookiePoint(
            line_id=row[0],
            color=row[1],
            x=row[2],
            y=row[3]
        )
        unsorted_cookie_pattern.append(point)

    # re order to group all colors together
    cookie_pattern: List[CookiePoint] = []
    for color in FROSTING_COLORS:
        for point in unsorted_cookie_pattern:
            if point.color == color:
                cookie_pattern.append(point)

    return cookie_pattern

# todo(chb, 12-15-2025): Extend this to have more than just the aspirate retract delay parameter, possibly convert to RTP
def get_frosting_class(ctx: protocol_api.ProtocolContext, asp_retract_delay: float, flow_rate: float) -> LiquidClass:
    """Returns a frosting liquid class based on the provided parameters."""
    return ctx.define_liquid_class(
        name="frosting",
        properties={"flex_1channel_1000" : {
            "opentrons/opentrons_flex_96_tiprack_1000ul/1" : TransferPropertiesDict(
                    aspirate=AspiratePropertiesDict(
                        submerge=SubmergeDict(
                            start_position=TipPositionDict(
                                position_reference=PositionReference.LIQUID_MENISCUS,
                                offset={"x": 0, "y": 0, "z": WAYPOINT_Z_HEIGHT},
                            ),
                            speed=10,
                            delay=DelayPropertiesDict(
                                enabled=False,
                            ),
                        ),
                        retract=RetractAspirateDict(
                            end_position=TipPositionDict(
                                position_reference=PositionReference.LIQUID_MENISCUS,
                                offset={"x": 0, "y": 0, "z": WAYPOINT_Z_HEIGHT},
                            ),
                            speed=10,
                            air_gap_by_volume=[(0.0, 0.0), (995.0, 0.0), (1000.0, 0.0)],
                            touch_tip=TouchTipPropertiesDict(enabled=False),
                            delay=DelayPropertiesDict(enabled=False),
                        ),
                        aspirate_position=TipPositionDict(
                            position_reference=PositionReference.LIQUID_MENISCUS_START,
                            offset={"x": 0, "y": 0, "z": -2},
                        ),
                        aspirate_end_position=TipPositionDict(
                            position_reference=PositionReference.LIQUID_MENISCUS_END,
                            offset={"x": 0, "y": 0, "z": -2},
                        ),
                        flow_rate_by_volume=[(0.0, flow_rate)],
                        correction_by_volume=[(0.0, 0.0)],
                        pre_wet=True,
                        mix=MixPropertiesDict(enabled=False),
                        delay=DelayPropertiesDict(
                            enabled=True,
                            duration=asp_retract_delay,
                        ),
                    ),
                    dispense=SingleDispensePropertiesDict(
                        submerge=SubmergeDict(
                            start_position=TipPositionDict(
                                position_reference=PositionReference.WELL_TOP,
                                offset={"x": 0, "y": 0, "z": 0},
                            ),
                            speed=10,
                            delay=DelayPropertiesDict(
                                enabled=False,
                            ),
                        ),
                        retract=RetractDispenseDict(
                            end_position=TipPositionDict(
                                position_reference=PositionReference.WELL_TOP,
                                offset={"x": 0, "y": 0, "z": 0},
                            ),
                            speed=10,
                            air_gap_by_volume=[(0.0, 0.0)],
                            touch_tip=TouchTipPropertiesDict(enabled=False),
                            delay=DelayPropertiesDict(enabled=False),
                            blowout=BlowoutPropertiesDict(
                                enabled=False,
                                location=BlowoutLocation.TRASH,
                                flow_rate=flow_rate,
                            ),
                        ),
                        dispense_position=TipPositionDict(
                            position_reference=PositionReference.WELL_TOP,
                            offset={"x": 0, "y": 0, "z": 0},
                        ),
                        flow_rate_by_volume=[(0.0, flow_rate)],
                        correction_by_volume=[(0.0, 0.0)],
                        push_out_by_volume=[(0.0, 0.0)],
                        mix=MixPropertiesDict(enabled=False),
                        delay=DelayPropertiesDict(enabled=False),
                    ),
                    multi_dispense=MultiDispensePropertiesDict(
                        submerge=SubmergeDict(
                            start_position=TipPositionDict(
                                position_reference=PositionReference.WELL_TOP,
                                offset={"x": 0, "y": 0, "z": 0},
                            ),
                            speed=10,
                            delay=DelayPropertiesDict(
                                enabled=False,
                            ),
                        ),
                        retract=RetractDispenseDict(
                            end_position=TipPositionDict(
                                position_reference=PositionReference.WELL_TOP,
                                offset={"x": 0, "y": 0, "z": 0},
                            ),
                            speed=10,
                            air_gap_by_volume=[(0.0, 0.0)],
                            touch_tip=TouchTipPropertiesDict(enabled=False),
                            delay=DelayPropertiesDict(enabled=False),
                            blowout=BlowoutPropertiesDict(
                                enabled=False,
                                location=BlowoutLocation.TRASH,
                                flow_rate=flow_rate,
                            ),
                        ),
                        dispense_position=TipPositionDict(
                            position_reference=PositionReference.WELL_TOP,
                            offset={"x": 0, "y": 0, "z": 0},
                        ),
                        flow_rate_by_volume=[(0.0, flow_rate)],
                        correction_by_volume=[(0.0, 0.0)],
                        delay=DelayPropertiesDict(enabled=False),
                        conditioning_by_volume= [(0,0)],
                        disposal_by_volume= [(0,0)],
                    ),
                )
            }
        }
    )


def run(ctx: protocol_api.ProtocolContext):
    # Retrieve Run Time Parameters
    csv_data = ctx.params.cookie_pattern.parse_as_csv()
    frosting_flow_rate = ctx.params.frosting_flow_rate
    frosting_per_mm = ctx.params.frosting_per_mm
    cookie_pattern = order_cookie_pattern(csv_data)

    # Load frosting tips and pipette
    tips = ctx.load_labware("opentrons_flex_96_tiprack_1000ul", "A2")
    pipette = ctx.load_instrument("flex_1channel_1000", "left", tip_racks=[tips])

    # Load cookie
    cookie = ctx.load_labware("opentrons_tough_cookie", "C2")

    # Load cookie dispenser and tip trash
    tip_trash = ctx.load_trash_bin("A3")

    frosting_lw = ctx.load_labware(f"opentrons_6_tuberack_nest_50ml_conical", "B2")

    # Frosting declarations
    frosting_class = get_frosting_class(ctx, asp_retract_delay=5, flow_rate=frosting_flow_rate)
    assert isinstance(frosting_class, LiquidClass)

    # Red
    red_frosting = ctx.define_liquid("red_frosting", "Red Frosting", "#FF0000")
    red_frosting_container = frosting_lw.well("A1")
    frosting_lw.load_liquid(["A1"], 45000, red_frosting)
    red_tip = tips["A1"]
    if ctx.params.use_lld:
        pipette.pick_up_tip(red_tip)
        pipette.require_liquid_presence(red_frosting_container)
        pipette.return_tip()
    # White
    white_frosting = ctx.define_liquid("white_frosting", "White Frosting", "#FFFFFF")
    white_frosting_container = frosting_lw.well("A2")
    frosting_lw.load_liquid(["A2"], 45000, white_frosting)
    white_tip = tips["B1"]
    if ctx.params.use_lld:
        pipette.pick_up_tip(white_tip)
        pipette.require_liquid_presence(white_frosting_container)
        pipette.return_tip()
    # Blue
    blue_frosting = ctx.define_liquid("blue_frosting", "Blue Frosting", "#0000FF")
    blue_frosting_container = frosting_lw.well("B1")
    frosting_lw.load_liquid(["B1"], 45000, blue_frosting)
    blue_tip = tips["C1"]
    if ctx.params.use_lld:
        pipette.pick_up_tip(blue_tip)
        pipette.require_liquid_presence(blue_frosting_container)
        pipette.return_tip()
    # Green
    green_frosting = ctx.define_liquid("green_frosting", "Green Frosting", "#00FF00")
    green_frosting_container = frosting_lw.well("B2")
    frosting_lw.load_liquid(["B2"], 45000, green_frosting)
    green_tip = tips["D1"]
    if ctx.params.use_lld:
        pipette.pick_up_tip(green_tip)
        pipette.require_liquid_presence(green_frosting_container)
        pipette.return_tip()
    # Yellow
    yellow_frosting = ctx.define_liquid("yellow_frosting", "Yellow Frosting", "#FFFF00")
    yellow_frosting_container = frosting_lw.well("A3")
    frosting_lw.load_liquid(["A3"], 45000, yellow_frosting)
    yellow_tip = tips["E1"]
    if ctx.params.use_lld:
        pipette.pick_up_tip(yellow_tip)
        pipette.require_liquid_presence(yellow_frosting_container)
        pipette.return_tip()

    #Get cookie Height

    if ctx.params.use_lld and not ctx.is_simulating():
        pipette.pick_up_tip(tips["F1"])
        well_z = pipette.measure_liquid_height(cookie.well("A1")) + DISPENSE_HEIGHT_ABOVE_COOKIE
        pipette.return_tip()
    else:
        well_z = 0


    def _color_to_tip(color: str):
        match color:
            case "Red":
                return red_tip
            case "White":
                return white_tip
            case "Blue":
                return blue_tip
            case "Green":
                return green_tip
            case "Yellow":
                return yellow_tip
            case _:
                # Use white frosting if the color was unidentified
                return white_tip

    def _color_to_well(color: str):
        match color:
            case "Red":
                return red_frosting_container
            case "White":
                return white_frosting_container
            case "Blue":
                return blue_frosting_container
            case "Green":
                return green_frosting_container
            case "Yellow":
                return yellow_frosting_container
            case _:
                # Use white frosting if the color was unidentified
                return white_frosting_container


    # Handle cookie decoration!
    previous_color = "none"
    contents: List[tx_comps_executor.LiquidAndAirGapPair] = []
    for i in range(len(cookie_pattern)):
        if i !=0 and cookie_pattern[i-1].line_id == cookie_pattern[i].line_id:
            if previous_color != cookie_pattern[i].color:
                if pipette.has_tip:
                    pipette.drop_tip(tip_trash)
                pipette.pick_up_tip(_color_to_tip(cookie_pattern[i].color))
                previous_color = cookie_pattern[i].color
            # These are part of the same line, start pipetting!
            dist = math.sqrt(((cookie_pattern[i].x - cookie_pattern[i-1].x) ** 2) + ((cookie_pattern[i].y - cookie_pattern[i-1].y) ** 2))
            frosting_volume = frosting_per_mm * dist if (frosting_per_mm * dist) <= FROSTING_MAX_VOLUME else FROSTING_MAX_VOLUME
            # Maybe we need a frosting min? Maybe that should be the frosting pet mm value.

            transfer_properties = frosting_class.get_for(
                pipette.name, tip_rack=tips.uri
            )
            # just in case it's a single dispense
            transfer_properties.dispense.submerge._start_position = TipPosition(
                    _position_reference=PositionReference.WELL_BOTTOM,
                    _offset=Coordinate(x=cookie_pattern[i-1].x, y=cookie_pattern[i-1].y, z=well_z+WAYPOINT_Z_HEIGHT)
            )
            transfer_properties.dispense.override_tip_positions(
                new_position=PositionReference.WELL_BOTTOM,
                new_offset=[cookie_pattern[i-1].x, cookie_pattern[i-1].y, well_z],
                new_end_position=PositionReference.WELL_BOTTOM,
                new_end_offset=[cookie_pattern[i].x, cookie_pattern[i].y, well_z],
            )
            transfer_properties.dispense.retract._end_position = TipPosition(
                    _position_reference=PositionReference.WELL_BOTTOM,
                    _offset=Coordinate(x=cookie_pattern[i].x, y=cookie_pattern[i].y, z=well_z+WAYPOINT_Z_HEIGHT)
            )
            # is more likely to be a multi dispense
            transfer_properties.multi_dispense.submerge._start_position = TipPosition(
                    _position_reference=PositionReference.WELL_BOTTOM,
                    _offset=Coordinate(x=cookie_pattern[i-1].x, y=cookie_pattern[i-1].y, z=well_z+WAYPOINT_Z_HEIGHT)
            )
            transfer_properties.multi_dispense.override_tip_positions(
                new_position=PositionReference.WELL_BOTTOM,
                new_offset=[cookie_pattern[i-1].x, cookie_pattern[i-1].y, well_z],
                new_end_position=PositionReference.WELL_BOTTOM,
                new_end_offset=[cookie_pattern[i].x, cookie_pattern[i].y, well_z],
            )
            transfer_properties.multi_dispense.retract._end_position = TipPosition(
                    _position_reference=PositionReference.WELL_BOTTOM,
                    _offset=Coordinate(x=cookie_pattern[i].x, y=cookie_pattern[i].y, z=well_z+WAYPOINT_Z_HEIGHT)
            )

            pipette._core.load_liquid_class(
                name=frosting_class.name,
                transfer_properties=transfer_properties,
                tiprack_uri=tips.uri
            )
            if pipette.current_volume < frosting_volume:
                # Handle liquid class aspiration
                try:
                    contents = pipette._core.aspirate_liquid_class(
                        volume=FROSTING_MAX_VOLUME-pipette.current_volume, # change this back to 1000 to be seperate from the max?
                        source=(
                            _color_to_well(cookie_pattern[i].color).top(),
                            _color_to_well(cookie_pattern[i].color)._core,
                        ),
                        transfer_properties=transfer_properties,
                        transfer_type=tx_comps_executor.TransferType.ONE_TO_ONE,
                        tip_contents=[
                            tx_comps_executor.LiquidAndAirGapPair(
                                liquid=0,
                                air_gap=0,
                            )
                        ],
                        volume_for_pipette_mode_configuration=None,
                    )
                except:
                    # todo (chb, 2025-12-17): Something in our aspiration calculations got mucked in the conversion to liquid classes which is why this is here.
                    # It will occasionally report a bad calculation for aspiration volume, so instead dispense all and reset to a clean level?
                    pipette._core.dispense_liquid_class(
                        volume=pipette.current_volume,
                        dest=(
                            _color_to_well(cookie_pattern[i].color).top(),
                            _color_to_well(cookie_pattern[i].color)._core,
                        ),
                        source=None,
                        transfer_properties=transfer_properties,
                        transfer_type=tx_comps_executor.TransferType.ONE_TO_ONE,
                        tip_contents=contents,
                        add_final_air_gap=False,
                        trash_location=tip_trash,
                    )
                    contents = pipette._core.aspirate_liquid_class(
                        volume=FROSTING_MAX_VOLUME-pipette.current_volume, # change this back to 1000 to be seperate from the max?
                        source=(
                            _color_to_well(cookie_pattern[i].color).top(),
                            _color_to_well(cookie_pattern[i].color)._core,
                        ),
                        transfer_properties=transfer_properties,
                        transfer_type=tx_comps_executor.TransferType.ONE_TO_ONE,
                        tip_contents=[
                            tx_comps_executor.LiquidAndAirGapPair(
                                liquid=0,
                                air_gap=0,
                            )
                        ],
                        volume_for_pipette_mode_configuration=None,
                    )

            ctx.comment(f"Drawing Line: First point x:{cookie_pattern[i-1].x} y:{cookie_pattern[i-1].y},  Second point x:{cookie_pattern[i].x} y:{cookie_pattern[i].y}")

            pipette._core.dispense_liquid_class(
                volume=frosting_volume,
                dest=(
                    cookie["A1"].top(),
                    cookie["A1"]._core,
                ),
                source=None,
                transfer_properties=transfer_properties,
                transfer_type=tx_comps_executor.TransferType.ONE_TO_ONE,
                tip_contents=contents,
                add_final_air_gap=False,
                trash_location=tip_trash,
            )

    pipette.drop_tip(tip_trash)

    # Dispense the cookie!
    ctx.capture_image(home_before=True, filename="Cookie_pic", zoom=2.0)
    ctx.pause(msg="GET READY TO CATCH THE DISPENSED COOKIE! HAPPY HOLIDAYS!")

    if ctx.params.use_gripper:
        cookie_chute = ctx.load_waste_chute()
        ctx.move_labware(cookie, cookie_chute, use_gripper=ctx.params.use_gripper)
